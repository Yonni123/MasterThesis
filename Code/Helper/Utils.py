import cv2
from keras.layers import GlobalAveragePooling2D
from keras.utils import load_img
from tensorflow.keras.models import Sequential, load_model, Model, clone_model
from tensorflow.keras.layers import Dense, Dropout, Flatten, Reshape, Conv2D, MaxPooling2D
from tensorflow.keras import backend as K
from keras.applications.resnet import ResNet50
from sys import platform
import pickle
import datetime
import tensorflow as tf
import numpy as np
tf.random.set_seed(1)   # For reproducibility
np.random.seed(1)


def join_models(obfuscation_model, inference_model):
    """
    Join an obfuscation model and an inference model into a combined model.

    Parameters:
    - obfuscation_model (Sequential): The obfuscation model.
    - inference_model (Sequential): The inference model.

    Returns:
    Sequential: The combined model.

    Raises:
    Exception: If the input and output shapes of the obfuscation model are not equal to the input shape of the inference model.
    """
    # Make sure that the input of the obfuscation model is equal to the output of the inference model
    if obfuscation_model.input_shape != inference_model.input_shape or obfuscation_model.output_shape != inference_model.input_shape:
        raise Exception('The input and output shapes of the obfuscation model are not equal to the input shape of the inference model')

    # Give the last layer the name "ObfNet_Out" to know where to split the model later
    combined_model = Sequential()
    combined_model.add(obfuscation_model)
    combined_model.add(inference_model)
    combined_model.layers[0]._name = 'ObfModel'
    combined_model.layers[1]._name = 'InfModel'
    return combined_model

def split_models(combined_model):
    """
    Split a combined model into its obfuscation model and inference model components.

    Parameters:
    - combined_model (Sequential): The combined model containing both obfuscation and inference models.

    Returns:
    tuple: A tuple containing the obfuscation model and the inference model.

    Raises:
    Exception: If the number of layers in the combined model is not 2.
    Exception: If 'ObfModel' is not found as the first layer in the combined model.
    Exception: If 'InfModel' is not found as the second layer in the combined model.

    Note:
    This function only works with combined models generated by join_models() function
    """
    if len(combined_model.layers) != 2:
        raise Exception('Wrong layer size, must be 2')
    if combined_model.layers[0].name != 'ObfModel':
        raise Exception('ObfModel was not found in the combined model')
    if combined_model.layers[1].name != 'InfModel':
        raise Exception('InfModel was not found in the combined model')
    return combined_model.layers[0], combined_model.layers[1]

def freeze_inf_model(combined_model):
    """
    Freeze the inference model within a combined model by setting its layers as non-trainable.

    Parameters:
    - combined_model (Sequential): The combined model containing both obfuscation and inference models.

    Returns:
    None

    Raises:
    Exception: If the number of layers in the combined model is not 2.
    Exception: If 'ObfModel' is not found as the first layer in the combined model.
    Exception: If 'InfModel' is not found as the second layer in the combined model.

    Note:
    This function only works with combined models generated by join_models() function
    """
    if len(combined_model.layers) != 2:
        raise Exception('Wrong layer size, must be 2')
    if combined_model.layers[0].name != 'ObfModel':
        raise Exception('ObfModel was not found in the combined model')
    if combined_model.layers[1].name != 'InfModel':
        raise Exception('InfModel was not found in the combined model')

    # Freeze the last layer of the inference model
    combined_model.layers[1].trainable = False


def get_pretrained_ResNet50():
    """
    Load a pre-trained ResNet50 model with weights trained on ImageNet.

    Returns:
    Model: A pre-trained ResNet50 model.

    Notes:
    - Make sure to have an internet connection as the weights are downloaded from the internet.
    """
    # Load the ResNet50 model with pre-trained weights
    base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

    # Freeze the layers of the base model
    for layer in base_model.layers:
        layer.trainable = False

    # Add custom classification layers
    x = base_model.output
    x = GlobalAveragePooling2D()(x)
    x = Dense(1024, activation='relu')(x)
    x = Dense(512, activation='relu')(x)
    predictions = Dense(10, activation='softmax')(x)

    # Create the final model
    model = Model(inputs=base_model.input, outputs=predictions)
    model.load_weights('../History/ResNet10c/session_20240130_133837_final.h5')
    return model

if __name__ == "__main__":
    model = get_pretrained_ResNet50()
    model.summary()
